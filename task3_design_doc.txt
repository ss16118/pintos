            +--------------------------+
            |          OS 211          |
            |  TASK 3: VIRTUAL MEMORY  |
            |      DESIGN DOCUMENT     |
            +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>
FirstName LastName <email@domain.example>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while preparing your 
>> submission, other than the Pintos documentation, course text, lecture notes 
>> and course staff.

            PAGE TABLE/FRAME MANAGEMENT
            =====================

---- DATA STRUCTURES ----

>> A1: (2 marks)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> supplemental page table and frame table. 
>> Identify the purpose of each in roughly 25 words.

struct spage_table_entry
{
  void *uaddr;

  bool writable;
  bool is_installed;
  bool is_swapped;
  
  char file_name[MAX_FILENAME_LEN];
  off_t ofs;
  size_t page_read_byte;
  swap_index swap_slot;
  struct hash_elem hash_elem;
};

The suppplementary page table stores all userpages that has been allocated.
This suppplementary page table is in every single thread.

struct thread
{
    ...
    struct hash spage_table;
    ...
};

As mentioned above, a suppplementary page table struct is now put into the thread struct.

struct frame_table_entry
{
   bool second_chance;
   bool pinned;

   struct thread *owner;
   void *kpage_addr;
   void *uaddr;                     /* We store this so we can find the upage
                                       via a given kpage and unmap it */
   struct list_elem elem;
};
The frame table keeps information of all the allocated frames.
"second_chance" and "pinned" help determine what frame is to be evicted.
"uaddr" and "owner" are used for unmapping and freeing resources.

---- ALGORITHMS ----

>> A2: (2 marks) 
>> Describe your code for finding the frame (if any) or other location that 
>> contains the data of a given page.

Given a page address, our program will lookup the page in the pagedir inside
the page directory. If it is found, we are able to obtain the frame. Otherwise,
the page_fault function will be called. In the page_fault function, our program
checks whether the page is in the suppplementary page table or not.

If the page is not is the suppplementary page table, we know the page address is
invalid and exit(-1) will be called. If the page exists in the suppplementary page table,
function "frame_add_entry" is called in which a frame is allocated for the page and the
entry is put into the frame table.

A page without frame is either not installed yet or its frame has been swapped out. 
Our "frame_add_entry" function determines which situation is is by checking the
"is_swapped" attribute in the struct spage_table_entry.

If the page is installed, the frame is swapped in using "swap_slot_to_frame".
If not, the page installed and a new frame is allocated to the page.


>> A3: (2 marks)
>> How have you implemented sharing of read only pages?

---- SYNCHRONIZATION ----

>> A4: (2 marks) 
>> When two user processes both need a new frame at the same time, how are 
>> races avoided? 
>> You should consider both when there are and are not free frames 
>> available in memory.

When a process needs a new frame, function "frame_add_entry" will be called
to obtain a new frame. The first thing that happen inside "frame_add_entry"
is to acquire the lock to the frame table. The lock is only released before
the return statements. This avoids race condition when getting a new frame.

If the there are no free frame, eviction will occur and "evict()" will be called.
There will be no race condition in this process because "evict()" is called inside
the "frame_add_entry" function, which is thoroughly synchronized.

So no matter whether the there are free frames or not, different thread will
get their frames without interfering will each other.


---- RATIONALE ----

>> A5: (2 marks)
>> Why did you choose the data structure(s) that you did for representing the
>> supplemental page table and frame table?

               PAGING TO AND FROM DISK
               =======================

---- DATA STRUCTURES ----

>> B1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> swap table.  
>> Identify the purpose of each in roughly 25 words.

---- ALGORITHMS ----

>> B2: (2 marks)
>> When a frame is required but none is free, some frame must be evicted.
>> Describe your code for choosing a frame to evict.

>> B3: (2 marks)
>> When a process P obtains a frame that was previously used by a process Q,
>> how do you adjust the page directory of process Q (and any other data 
>> structures) to reflect the frame Q no longer has?

---- SYNCHRONIZATION ----

>> B4: (2 marks)
>> Explain how your synchronization design prevents deadlock.  
>> (You may want to refer to the necessary conditions for deadlock.)

>> B5: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you ensure that Q cannot access or modify the page during the 
>> eviction process?

>> B6: (2 marks)
>> A page fault in process P can cause another process Q's frame to be evicted.
>> How do you avoid a race between P evicting Q's frame and Q faulting the page
>> back in?

>> B7: (2 marks)
>> Explain how you handle access to user pages that are not present when a
>> system call is made.

---- RATIONALE ----

>> B8: (2 marks)
>> There is an obvious trade-off between parallelism and the complexity of your
>> synchronisation methods. 
>> Explain where your design falls along this continuum and why you chose to 
>> design it this way.

             MEMORY MAPPED FILES
             ===================

---- DATA STRUCTURES ----

>> C1: (1 mark)
>> Copy here the declaration of each new or changed `struct' or `struct' member,
>> global or static variable, `typedef', or enumeration that relates to your 
>> file mapping table.  
>> Identify the purpose of each in roughly 25 words.

struct file_mmap
{
  mapid_t map_id;
  char file_name[MAX_FILENAME_LEN];
  struct thread *owner;
  size_t file_size;
  void *uaddr;
  struct list_elem elem;
};

The data structre stores an user address and an opened file.
When the mapped file needs to be used, the corresponding address can be found

---- ALGORITHMS ----

>> C2: (3 marks)
>> Explain how you determine whether a new file mapping overlaps with any 
>> existing segment and how you handle such a case. 
>> Additionally, how might this interact with stack growth?

When a new mapping is about to be created, we are given the file_descriptor and
starting address of the memory map. Using the file_descriptor we are able to obtain
the size of the file that is to be mapped. We can compute the number of memory pages
needed to store the file: number_of_pages = (file_size - 1) / PGSIZE + 1

We use a for loop to check the address of each of the pages. if any of them is present
in the suppplementary page table, it means the file cannot be mapped.

It doesn't really interact with stack growth.

TODO make up some realtion.

---- RATIONALE ----

>> C3: (1 mark)
>> Mappings created with "mmap" have similar semantics to those of data 
>> demand-paged from executables. 
>> How does your code-base take advantage of this?
